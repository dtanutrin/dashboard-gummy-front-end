# GUIA DE INTEGRAÇÃO FRONTEND - SISTEMA DE PERMISSÕES GRANULARES

## 🚨 CORREÇÕES URGENTES DE BACKEND

### 1. Middleware de Autenticação
PROBLEMA: Token não está sendo reconhecido corretamente

VERIFICAR:
- Middleware `authenticateToken` em `/middleware/authenticateToken.js`
- Header deve ser: `Authorization: Bearer <token>`
- Token deve estar válido e não expirado

### 2. Endpoint Dashboard Permissions
PROBLEMA: 403 Forbidden em `/api/dashboard-permissions/user/54`

SOLUÇÃO BACKEND:
- Verificar se middleware `isAdmin` está funcionando
- Usuário com role "User" NÃO pode acessar este endpoint
- Apenas usuários com role "Admin" podem gerenciar permissões

### 3. CORS Configuration
VERIFICAR arquivo `/middleware/cors.js`:
```javascript
res.header('Access-Control-Allow-Origin', process.env.FRONTEND_URL || 'http://localhost:3000');
res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');



## ENDPOINTS NECESSÁRIOS PARA O FRONTEND
### Autenticação
```
POST /api/auth/login
Body: { email, password }
Response: { token, user: { 
id, email, role, areas } }
```

### Áreas (com dashboards filtrados)
```
GET /api/areas
Headers: Authorization: 
Bearer <token>
Response: [{ id, name, 
dashboards: [...] }]
```
### Gerenciamento de Permissões (APENAS ADMIN)
```
GET /api/
dashboard-permissions/user/
:userId
Headers: Authorization: 
Bearer <admin_token>
Response: [{ dashboardId, 
dashboard: {...} }]

POST /api/
dashboard-permissions/grant
Headers: Authorization: 
Bearer <admin_token>
Body: { userId, dashboardId }

POST /api/
dashboard-permissions/revoke
Headers: Authorization: 
Bearer <admin_token>
Body: { userId, dashboardId }
```

### Usuários (APENAS ADMIN)
```
GET /api/users
POST /api/users
PUT /api/users/:id
DELETE /api/users/:id
```

## CONFIGURAÇÕES FRONTEND NECESSÁRIAS
### 1. Axios Interceptor
```
// Configurar interceptor 
para incluir token 
automaticamente
axios.interceptors.request.
use(
  (config) => {
    const token = 
    localStorage.getItem
    ('token');
    if (token) {
      config.headers.
      Authorization = 
      `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject
  (error)
);

// Interceptor para tratar 
erros de autenticação
axios.interceptors.response.
use(
  (response) => response,
  (error) => {
    if (error.response?.
    status === 401) {
      localStorage.removeItem
      ('token');
      window.location.href = 
      '/login';
    }
    return Promise.reject
    (error);
  }
);
```
### 2. Gerenciamento de Estado de Autenticação
```
// Context ou store para 
gerenciar autenticação
const AuthContext = {
  user: null,
  token: null,
  isAdmin: false,
  login: (credentials) => {
    // POST /api/auth/login
    // Salvar token e user 
    no localStorage
    // Atualizar estado
  },
  logout: () => {
    localStorage.removeItem
    ('token');
    localStorage.removeItem
    ('user');
    // Redirecionar para 
    login
  }
};
```

### 3. Componente de Permissões (ADMIN)
```
// Tela para gerenciar 
permissões de usuário
const UserPermissions = ({ 
userId }) => {
  const [userDashboards, 
  setUserDashboards] = 
  useState([]);
  const 
  [availableDashboards, 
  setAvailableDashboards] = 
  useState([]);
  
  // Carregar permissões 
  atuais do usuário
  useEffect(() => {
    fetchUserDashboards
    (userId);
    fetchAvailableDashboards
    ();
  }, [userId]);
  
  const grantAccess = async 
  (dashboardId) => {
    await axios.post('/api/
    dashboard-permissions/
    grant', {
      userId,
      dashboardId
    });
    // Atualizar lista
  };
  
  const revokeAccess = async 
  (dashboardId) => {
    await axios.post('/api/
    dashboard-permissions/
    revoke', {
      userId,
      dashboardId
    });
    // Atualizar lista
  };
};
```

### 4. Proteção de Rotas
```
// HOC para proteger rotas 
que precisam de admin
const RequireAdmin = ({ 
children }) => {
  const { user } = useAuth();
  
  if (!user || user.role !== 
  'Admin') {
    return <Navigate to="/
    unauthorized" />;
  }
  
  return children;
};

// Uso:
<Route path="/admin/
permissions" element={
  <RequireAdmin>
    <UserPermissions />
  </RequireAdmin>
} />
```
## CORREÇÕES PARA ERROS ESPECÍFICOS
### Service Worker Cache Error
```
// Desabilitar ou corrigir 
service worker
// Em index.js ou App.js:
if ('serviceWorker' in 
navigator) {
  navigator.serviceWorker.
  getRegistrations().then
  (registrations => {
    registrations.forEach
    (registration => 
    registration.unregister
    ());
  });
}
```

### Axios Error Handling
```
// Melhor tratamento de erros
const apiCall = async () => {
  try {
    const response = await 
    axios.get('/api/areas');
    return response.data;
  } catch (error) {
    if (error.response?.
    status === 403) {
      console.error('Acesso 
      negado - verifique 
      permissões');
    } else if (error.
    response?.status === 
    401) {
      console.error('Token 
      inválido - faça login 
      novamente');
    }
    throw error;
  }
};
```

### Frontend:
- Configurar interceptors do Axios
- Implementar gerenciamento de estado de auth
- Criar componente de permissões para admin
- Adicionar proteção de rotas
- Tratar erros de autenticação adequadamente
- Testar fluxo completo de login → áreas → permissões

##  PONTOS DE ATENÇÃO
1. Segurança : Sempre validar role no backend, nunca confiar apenas no frontend
2. Performance : Implementar cache inteligente para listas de áreas/dashboards
3. UX : Mostrar mensagens claras para erros de permissão
4. Logs : Implementar logging adequado para debug de permissões

### Correção Necessária:
```
// Obter uma Área por ID com 
seus Dashboards (Filtrado 
por permissão)
export const getAreaById = 
async (req, res) => {
  const { id } = req.params;
  const user = req.user;
  try {
    const areaId = parseInt
    (id);
    if (user.role !== 
    "Admin") {
      const access = await 
      prisma.userAreaAccess.
      findUnique({
        where: {
          userId_areaId: {
            userId: user.
            userId,
            areaId: areaId,
          },
        },
      });
      if (!access) {
        return res.status
        (403).json({ error: 
        "Acesso negado a 
        esta área." });
      }
    }

    let area;
    if (user.role === 
    "Admin") {
      // Admin vê todos os 
      dashboards
      area = await prisma.
      area.findUnique({
        where: { id: 
        areaId },
        include: {
          dashboards: true,
        },
      });
    } else {
      // Usuário regular: 
      filtrar dashboards por 
      permissão específica
      const 
      userDashboardAccesses 
      = await prisma.
      userDashboardAccess.
      findMany({
        where: { 
          userId: user.
          userId,
          dashboard: {
            areaId: areaId
          }
        },
        include: {
          dashboard: true
        }
      });

      area = await prisma.
      area.findUnique({
        where: { id: areaId }
      });

      if (area) {
        // Incluir apenas 
        dashboards com 
        permissão específica
        area.dashboards = 
        userDashboardAccesses
        .map(access => 
        access.dashboard);
      }
    }

    if (!area) {
      return res.status(404).
      json({ error: "Área 
      não encontrada." });
    }
    res.json(area);
  } catch (error) {
    console.error("Erro ao 
    buscar área por ID com 
    dashboards:", error);
    res.status(500).json({ 
    error: "Erro interno do 
    servidor ao buscar área.
    " });
  }
};
```